name: Simple Build and Deploy

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    name: Build Docker and Deploy to AWS EC2
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create required directories for build context
      run: |
        mkdir -p data/processed/rag_index
        mkdir -p data/raw
        touch data/processed/rag_index/.gitkeep
        touch data/raw/.gitkeep

    - name: Build Docker image
      run: |
        docker build -f Dockerfile.optimized -t hr-policy-forecast:latest .

    - name: Save Docker image as artifact
      run: |
        docker save hr-policy-forecast:latest | gzip > hr-policy-forecast.tar.gz

    - name: Deploy to AWS EC2
      env:
        AWS_PRIVATE_KEY: ${{ secrets.AWS_PRIVATE_KEY }}
        AWS_HOST: ${{ secrets.AWS_HOST }}
        AWS_USER: ${{ secrets.AWS_USER }}
      run: |
        # Save private key to file
        echo "$AWS_PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem
        
        # Copy Docker image to EC2
        scp -i private_key.pem -o StrictHostKeyChecking=no hr-policy-forecast.tar.gz $AWS_USER@$AWS_HOST:/tmp/
        
        # Deploy on EC2
        ssh -i private_key.pem -o StrictHostKeyChecking=no $AWS_USER@$AWS_HOST << 'EOF'
          # Stop and remove any containers using port 8000
          echo "üîç Checking for containers using port 8000..."
          CONTAINERS_ON_PORT=$(docker ps -q --filter "publish=8000")
          if [ ! -z "$CONTAINERS_ON_PORT" ]; then
            echo "Stopping containers using port 8000: $CONTAINERS_ON_PORT"
            docker stop $CONTAINERS_ON_PORT
            docker rm $CONTAINERS_ON_PORT
          fi
          
          # Also try to stop by name (in case it exists but not using the port)
          docker stop hr-policy-forecast 2>/dev/null || true
          docker rm hr-policy-forecast 2>/dev/null || true
          
          # Kill any process using port 8000 as backup
          sudo fuser -k 8000/tcp 2>/dev/null || true
          
          # Wait a moment for port to be released
          sleep 5
          
          # Load new image
          cd /tmp
          docker load < hr-policy-forecast.tar.gz
          
          # Run new container
          echo "üöÄ Starting new container..."
          docker run -d \
            --name hr-policy-forecast \
            -p 8000:8000 \
            --restart unless-stopped \
            hr-policy-forecast:latest
          
          # Clean up
          rm hr-policy-forecast.tar.gz
          
          # Wait a moment for container to start
          sleep 15
          
          # Check if container is running
          if docker ps | grep hr-policy-forecast; then
            echo "‚úÖ Deployment successful!"
            echo "Container status:"
            docker ps | grep hr-policy-forecast
          else
            echo "‚ùå Deployment failed!"
            echo "Container logs:"
            docker logs hr-policy-forecast 2>/dev/null || echo "No logs available"
            exit 1
          fi
        EOF
        
        # Clean up private key
        rm private_key.pem

    - name: Verify deployment
      env:
        AWS_PRIVATE_KEY: ${{ secrets.AWS_PRIVATE_KEY }}
        AWS_HOST: ${{ secrets.AWS_HOST }}
        AWS_USER: ${{ secrets.AWS_USER }}
      run: |
        # Save private key to file
        echo "$AWS_PRIVATE_KEY" > private_key.pem
        chmod 600 private_key.pem
        
        # Test the deployed application from inside EC2
        ssh -i private_key.pem -o StrictHostKeyChecking=no $AWS_USER@$AWS_HOST << 'EOF'
          echo "üîç Waiting for application to start..."
          
          # Wait up to 60 seconds for the application to be ready
          for i in {1..12}; do
            echo "Health check attempt $i/12..."
            
            # Check if container is still running
            if ! docker ps | grep hr-policy-forecast; then
              echo "‚ùå Container stopped running!"
              echo "Container logs:"
              docker logs hr-policy-forecast
              exit 1
            fi
            
            # Try health check from localhost (inside EC2)
            if curl -f -s http://localhost:8000/health > /dev/null 2>&1; then
              echo "‚úÖ Health check passed!"
              echo "Application is running at http://localhost:8000"
              
              # Get the actual health response
              echo "Health endpoint response:"
              curl -s http://localhost:8000/health || echo "Could not get response"
              exit 0
            else
              echo "‚è≥ Application not ready yet, waiting 5 seconds..."
              sleep 5
            fi
          done
          
          # If we get here, health check failed
          echo "‚ùå Health check failed after 60 seconds!"
          echo "Container status:"
          docker ps | grep hr-policy-forecast || echo "Container not found"
          echo "Container logs:"
          docker logs hr-policy-forecast
          exit 1
        EOF
        
        # Clean up private key
        rm private_key.pem
        
        echo "‚úÖ Application is running successfully on AWS EC2!"
        echo "üåê Access your application at: http://$AWS_HOST:8000"
        echo "üí° Note: Make sure port 8000 is open in your EC2 security group for external access"